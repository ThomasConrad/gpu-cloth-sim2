# Task 007: GPU-based Normal Computation

**Epic:** CLOTH-001  
**Milestone:** 2 - Enhanced Physics  
**Effort:** 1.5 days (3 story points)  
**Priority:** Medium  
**Parallelizable:** Yes - Independent rendering improvement  

## Overview

Implement GPU-based normal computation for smooth cloth shading, replacing the simple fixed normals from the minimal rendering pipeline. This includes per-vertex normal calculation from adjacent triangles and integration with the existing vertex pulling rendering system.

## Technical Requirements

### Normal Computation Algorithm
- Per-vertex normals calculated from adjacent triangle faces
- Area-weighted averaging for proper normal distribution
- GPU compute shader implementation for efficiency
- Integration with existing vertex pulling rendering pipeline

### Compute Shader Implementation
```wgsl
@compute @workgroup_size(64, 1, 1)
fn compute_normals(
    @builtin(global_invocation_id) id: vec3<u32>
) {
    let vertex_id = id.x;
    if (vertex_id >= vertex_count) { return; }
    
    var accumulated_normal = vec3<f32>(0.0);
    var total_area = 0.0;
    
    // Iterate through adjacent triangles
    let triangle_start = vertex_triangle_offsets[vertex_id];
    let triangle_count = vertex_triangle_counts[vertex_id];
    
    for (var i = 0u; i < triangle_count; i++) {
        let triangle_id = adjacent_triangles[triangle_start + i];
        let triangle = triangles[triangle_id];
        
        // Get triangle vertices
        let p0 = positions[triangle.indices[0]].xyz;
        let p1 = positions[triangle.indices[1]].xyz;
        let p2 = positions[triangle.indices[2]].xyz;
        
        // Calculate face normal and area
        let edge1 = p1 - p0;
        let edge2 = p2 - p0;
        let face_normal = cross(edge1, edge2);
        let area = length(face_normal) * 0.5;
        
        // Accumulate area-weighted normal
        accumulated_normal += normalize(face_normal) * area;
        total_area += area;
    }
    
    // Store normalized result
    if (total_area > 1e-6) {
        normals[vertex_id] = vec4(normalize(accumulated_normal), 0.0);
    } else {
        normals[vertex_id] = vec4(0.0, 1.0, 0.0, 0.0); // Default up normal
    }
}
```

## Implementation Details

### Adjacency Data Structure
```rust
struct VertexAdjacency {
    vertex_triangle_offsets: Buffer<u32>,    // Offset into adjacent triangles
    vertex_triangle_counts: Buffer<u32>,     // Number of adjacent triangles per vertex
    adjacent_triangles: Buffer<u32>,         // Flattened list of triangle indices
    triangles: Buffer<TriangleIndices>,      // Triangle vertex indices
}
```

### Triangle Adjacency Generation
```rust
fn build_vertex_adjacency(width: u32, height: u32) -> VertexAdjacency {
    let mut adjacency_map = HashMap<u32, Vec<u32>>::new();
    
    // Generate triangle indices
    let triangles = generate_cloth_triangles(width, height);
    
    // Build adjacency lists
    for (triangle_id, triangle) in triangles.iter().enumerate() {
        for &vertex_id in triangle.indices.iter() {
            adjacency_map.entry(vertex_id)
                .or_insert_with(Vec::new)
                .push(triangle_id as u32);
        }
    }
    
    // Flatten into GPU buffers
    flatten_adjacency_data(adjacency_map)
}
```

### Integration with Rendering Pipeline
- Add normals buffer to existing GPU buffer management
- Update vertex shader to use computed normals
- Maintain normal buffer alongside position updates
- Trigger normal recomputation after physics steps

### Normal Buffer Management
```rust
impl BufferManager {
    fn add_normal_buffer(&mut self, vertex_count: u32) {
        self.normals = self.device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Normal Buffer"),
            size: (vertex_count * std::mem::size_of::<[f32; 4]>() as u32) as u64,
            usage: wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_DST,
            mapped_at_creation: false,
        });
    }
    
    fn update_normals(&mut self, encoder: &mut wgpu::CommandEncoder) {
        // Dispatch normal computation compute shader
        let mut compute_pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
            label: Some("Normal Computation"),
        });
        compute_pass.set_pipeline(&self.normal_compute_pipeline);
        compute_pass.set_bind_group(0, &self.compute_bind_group, &[]);
        compute_pass.dispatch_workgroups(
            (self.vertex_count + 63) / 64, 1, 1
        );
    }
}
```

## Acceptance Criteria

- [ ] **Visual Quality**: Significant improvement in cloth shading quality over flat normals
- [ ] **Performance**: Normal computation completes in <1ms per frame on GTX 1660
- [ ] **Correctness**: Normals properly reflect cloth surface curvature and folding
- [ ] **Integration**: Seamless integration with existing rendering pipeline
- [ ] **Stability**: Normal computation remains stable during cloth animation
- [ ] **Memory Usage**: Minimal memory overhead for normal storage and adjacency data

## Dependencies

### Prerequisites
- Task 003 (Minimal Rendering Pipeline) - extends rendering system
- Task 001 (GPU Buffer Management System) - requires normal buffer management
- Triangle mesh topology from cloth generation

### Blocks
- Advanced lighting and material systems in later milestones
- Debug visualization improvements

### Can Work In Parallel With
- Task 005 (Bending Constraints) - different subsystem
- Task 006 (Advanced Force System) - independent physics feature

## Testing Strategy

### Visual Validation
```rust
#[test]
fn normal_computation_accuracy() {
    // Test normal calculation against analytical solutions for simple meshes
}

#[test]
fn adjacency_data_correctness() {
    // Verify adjacency data structure is built correctly
}

#[test]
fn normal_computation_performance() {
    // Benchmark normal computation performance
}
```

### Rendering Tests
- Compare rendered output before/after normal implementation
- Normal vector visualization for debugging
- Performance regression testing
- Memory usage validation

## Technical Specifications

### Buffer Layout
```rust
struct NormalComputeBuffers {
    positions: Buffer<Vec4>,              // Input: particle positions
    normals: Buffer<Vec4>,                // Output: computed normals
    vertex_triangle_offsets: Buffer<u32>, // Adjacency: triangle list offsets
    vertex_triangle_counts: Buffer<u32>,  // Adjacency: triangle counts per vertex
    adjacent_triangles: Buffer<u32>,      // Adjacency: triangle indices
    triangle_indices: Buffer<TriangleIndices>, // Triangle vertex indices
}
```

### Shader Interface
```wgsl
struct TriangleIndices {
    indices: array<u32, 3>,
}

@group(0) @binding(0) var<storage, read> positions: array<vec4<f32>>;
@group(0) @binding(1) var<storage, read_write> normals: array<vec4<f32>>;
@group(0) @binding(2) var<storage, read> vertex_triangle_offsets: array<u32>;
@group(0) @binding(3) var<storage, read> vertex_triangle_counts: array<u32>;
@group(0) @binding(4) var<storage, read> adjacent_triangles: array<u32>;
@group(0) @binding(5) var<storage, read> triangle_indices: array<TriangleIndices>;
```

## Performance Targets

- **Normal Computation**: <1ms per frame for 32x32 cloth (1024 vertices)
- **Memory Usage**: <500KB additional memory for adjacency data
- **Workgroup Efficiency**: >90% GPU compute utilization
- **Rendering Impact**: No measurable performance loss in vertex shader

## Risk Factors

- **Adjacency Data Size**: Large meshes may have significant adjacency overhead
- **Memory Bandwidth**: Additional buffer reads may impact performance
- **Topology Changes**: Dynamic mesh changes would require adjacency rebuilding
- **Degenerate Triangles**: Zero-area triangles may cause division by zero

## Implementation Notes

### Optimization Opportunities
- Consider caching adjacency data in texture for better memory access
- Use shared memory for triangle data access within workgroups
- Implement early termination for boundary vertices with fewer triangles

### Algorithm Variations
- **Angle-weighted**: Weight normals by vertex angle in triangle
- **Area-weighted**: Weight normals by triangle area (implemented)
- **Uniform**: Simple average of adjacent face normals

### Integration Considerations
- Normal computation should be triggered after each physics step
- Consider double-buffering normals for temporal stability
- Plan for future features like smooth normal interpolation
- Consider normal map support for enhanced detail