# Task 012: Interactive Vertex Manipulation

**Epic:** CLOTH-001  
**Milestone:** 4 - User Interaction  
**Effort:** 3 days (8 story points)  
**Priority:** High  
**Parallelizable:** No - Integrates multiple systems  

## Overview

Implement interactive vertex manipulation system with mouse-based vertex picking using ray casting, pin/unpin functionality with visual feedback, drag-based vertex positioning with force application, and attachment constraint management integrated with the XPBD physics system.

## Technical Requirements

### Mouse Ray Casting System
- Convert mouse coordinates to world-space ray
- Ray-triangle intersection testing for vertex selection
- Efficient spatial querying for nearby vertices
- Visual feedback for hover and selection states

### Pin/Unpin Functionality
- Toggle vertex attachment to fixed world positions
- Visual indicators for pinned vertices
- Constraint management for pinned particles
- Undo/redo support for pin operations

### Interactive Dragging System
```rust
struct VertexManipulation {
    selected_vertex: Option<u32>,
    is_dragging: bool,
    drag_start_position: Vec3,
    drag_current_position: Vec3,
    drag_force_strength: f32,
    pinned_vertices: HashSet<u32>,
    attachment_constraints: Vec<AttachmentConstraint>,
}
```

## Implementation Details

### Ray Casting Implementation
```rust
struct Ray {
    origin: Vec3,
    direction: Vec3,
}

impl Camera {
    fn screen_to_world_ray(&self, screen_pos: Vec2, screen_size: Vec2) -> Ray {
        // Convert screen coordinates to normalized device coordinates
        let ndc_x = (screen_pos.x / screen_size.x) * 2.0 - 1.0;
        let ndc_y = 1.0 - (screen_pos.y / screen_size.y) * 2.0;
        
        // Unproject to world space
        let inv_view_proj = (self.view_matrix * self.projection_matrix).inverse();
        let near_point = inv_view_proj * Vec4::new(ndc_x, ndc_y, -1.0, 1.0);
        let far_point = inv_view_proj * Vec4::new(ndc_x, ndc_y, 1.0, 1.0);
        
        let near = near_point.xyz() / near_point.w;
        let far = far_point.xyz() / far_point.w;
        
        Ray {
            origin: near,
            direction: (far - near).normalize(),
        }
    }
}

impl VertexPicker {
    fn pick_vertex(&self, ray: Ray, positions: &[Vec4], threshold: f32) -> Option<u32> {
        let mut closest_vertex = None;
        let mut closest_distance = f32::INFINITY;
        
        for (i, position) in positions.iter().enumerate() {
            let to_vertex = position.xyz() - ray.origin;
            let projection = to_vertex.dot(ray.direction);
            
            if projection > 0.0 {
                let closest_point = ray.origin + ray.direction * projection;
                let distance = (position.xyz() - closest_point).length();
                
                if distance < threshold && projection < closest_distance {
                    closest_distance = projection;
                    closest_vertex = Some(i as u32);
                }
            }
        }
        
        closest_vertex
    }
}
```

### Attachment Constraint System
```rust
#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct AttachmentConstraint {
    particle_id: u32,
    target_position: Vec3,
    compliance: f32,        // 0.0 = rigid attachment, >0.0 = soft attachment
    is_active: u32,
    constraint_type: u32,   // PIN or DRAG
}

impl AttachmentConstraint {
    fn new_pin(particle_id: u32, position: Vec3) -> Self {
        Self {
            particle_id,
            target_position: position,
            compliance: 0.0,    // Rigid pin
            is_active: 1,
            constraint_type: CONSTRAINT_TYPE_PIN,
        }
    }
    
    fn new_drag(particle_id: u32, target: Vec3, strength: f32) -> Self {
        Self {
            particle_id,
            target_position: target,
            compliance: 1.0 / strength,  // Soft drag
            is_active: 1,
            constraint_type: CONSTRAINT_TYPE_DRAG,
        }
    }
}
```

### XPBD Integration for Attachment
```wgsl
@compute @workgroup_size(64, 1, 1)
fn solve_attachment_constraints(
    @builtin(global_invocation_id) id: vec3<u32>
) {
    let constraint_id = id.x;
    if (constraint_id >= attachment_count) { return; }
    
    let constraint = attachment_constraints[constraint_id];
    if (constraint.is_active == 0u) { return; }
    
    let particle_id = constraint.particle_id;
    let current_pos = positions[particle_id].xyz;
    let target_pos = constraint.target_position;
    let mass = positions[particle_id].w;
    
    // Calculate constraint violation
    let constraint_vector = current_pos - target_pos;
    let constraint_length = length(constraint_vector);
    
    if (constraint_length > 1e-6) {
        let constraint_direction = constraint_vector / constraint_length;
        
        // XPBD lambda calculation with compliance
        let compliance = constraint.compliance / (dt * dt);
        let denominator = (1.0 / mass) + compliance;
        let lambda = -constraint_length / denominator;
        
        // Apply position correction
        let delta_position = constraint_direction * (lambda / mass);
        position_corrections[particle_id] += vec4(delta_position, 0.0);
    }
}
```

### Visual Feedback System
```rust
struct InteractionVisuals {
    pinned_vertex_renderer: PointRenderer,
    selection_highlight_renderer: CircleRenderer,
    drag_line_renderer: LineRenderer,
}

impl InteractionVisuals {
    fn render_pinned_vertices(&mut self, pinned_vertices: &HashSet<u32>, positions: &[Vec4]) {
        for &vertex_id in pinned_vertices {
            let position = positions[vertex_id as usize].xyz();
            self.pinned_vertex_renderer.draw_point(
                position, 
                0.02,                    // Size
                Vec3::new(1.0, 1.0, 0.0) // Yellow color
            );
        }
    }
    
    fn render_selection_highlight(&mut self, vertex_id: Option<u32>, positions: &[Vec4]) {
        if let Some(id) = vertex_id {
            let position = positions[id as usize].xyz();
            self.selection_highlight_renderer.draw_circle(
                position,
                0.03,                    // Radius
                Vec3::new(0.0, 1.0, 0.0) // Green color
            );
        }
    }
    
    fn render_drag_indicator(&mut self, drag_info: &DragInfo, positions: &[Vec4]) {
        if let Some(vertex_id) = drag_info.selected_vertex {
            let start_pos = positions[vertex_id as usize].xyz();
            let end_pos = drag_info.target_position;
            
            self.drag_line_renderer.draw_line(
                start_pos,
                end_pos,
                Vec3::new(1.0, 0.0, 1.0) // Magenta color
            );
        }
    }
}
```

## Acceptance Criteria

- [ ] **Vertex Selection**: Mouse clicking accurately selects cloth vertices
- [ ] **Pin Functionality**: Right-click pins/unpins vertices with visual feedback
- [ ] **Drag Interaction**: Left-click drag moves vertices with realistic force application
- [ ] **Visual Feedback**: Clear visual indicators for pinned, selected, and dragged vertices
- [ ] **Physics Integration**: Interaction forces integrate seamlessly with cloth physics
- [ ] **Performance**: Interaction system adds <1ms per frame to rendering pipeline

## Dependencies

### Prerequisites
- Task 004 (Application Framework) - mouse input handling
- Task 002 (Basic XPBD Physics Pipeline) - constraint system integration
- Task 003 (Minimal Rendering Pipeline) - camera system for ray casting

### Blocks
- Task 015 (Scene Management) - uses pin/unpin state in scene saving
- Advanced manipulation features in future milestones

### Can Work In Parallel With
- Task 013 (Advanced Parameter Controls) - different UI subsystem
- Task 014 (Scene Management) - different feature area

## Testing Strategy

### Interaction Tests
```rust
#[test]
fn ray_casting_accuracy() {
    // Test mouse ray casting produces correct world-space rays
}

#[test]
fn vertex_picking_accuracy() {
    // Test vertex selection works correctly at various distances and angles
}

#[test]
fn pin_constraint_behavior() {
    // Test pinned vertices remain fixed during simulation
}

#[test]
fn drag_force_application() {
    // Test drag forces are applied correctly and feel responsive
}
```

### User Experience Testing
- Test interaction responsiveness at various frame rates
- Validate visual feedback clarity and timing
- Test interaction accuracy across different screen resolutions
- Measure interaction latency from input to visual feedback

## Technical Specifications

### Interaction State Management
```rust
struct InteractionState {
    hovered_vertex: Option<u32>,
    selected_vertex: Option<u32>,
    pinned_vertices: HashSet<u32>,
    drag_active: bool,
    drag_target: Vec3,
    mouse_sensitivity: f32,
    pick_threshold: f32,
}
```

### Attachment Constraint Buffer
```rust
struct AttachmentSystem {
    constraints: Buffer<AttachmentConstraint>,
    constraint_count: u32,
    max_constraints: u32,
    dirty_flag: bool, // Indicates buffer needs updating
}
```

### Input Event Handling
```rust
impl InteractionSystem {
    fn handle_mouse_event(&mut self, event: MouseEvent, camera: &Camera) -> bool {
        match event {
            MouseEvent::Move(pos) => {
                self.update_hover_selection(pos, camera);
                if self.interaction_state.drag_active {
                    self.update_drag_target(pos, camera);
                }
            }
            
            MouseEvent::ButtonDown(button, pos) => {
                match button {
                    MouseButton::Left => self.start_drag(pos, camera),
                    MouseButton::Right => self.toggle_pin(pos, camera),
                    _ => return false,
                }
            }
            
            MouseEvent::ButtonUp(MouseButton::Left) => {
                self.end_drag();
            }
            
            _ => return false,
        }
        true
    }
}
```

## Performance Targets

- **Ray Casting**: <0.1ms per mouse movement
- **Vertex Selection**: <0.2ms for vertex picking operation
- **Visual Feedback**: <1ms for interaction visualization rendering
- **Constraint Updates**: <0.3ms for attachment constraint buffer updates

## Risk Factors

- **Selection Accuracy**: Small vertices may be difficult to select precisely
- **Performance Impact**: Ray casting and selection may impact frame rate
- **Physics Integration**: Attachment constraints may interfere with cloth stability
- **User Experience**: Interaction may feel unresponsive or imprecise

## Implementation Notes

### Optimization Strategies
- Use spatial acceleration structures for faster vertex queries
- Implement selection tolerance that adapts to camera distance
- Cache ray casting results for mouse movements within small threshold
- Use instanced rendering for multiple selection indicators

### User Experience Considerations
- Provide visual preview of pin operation before committing
- Implement smooth interpolation for drag target updates
- Consider haptic feedback simulation through force visualization
- Add keyboard modifiers for different interaction modes

### Integration Points
- Attachment constraints should be processed after physics constraints
- Visual feedback rendering should occur after physics update
- Mouse input should be processed in screen space before world conversion
- Consider interaction state persistence for scene saving/loading

### Future Extensions
- Multi-vertex selection with box select
- Vertex group pinning/unpinning
- Constraint visualization (springs between pinned points)
- Advanced manipulation tools (rotate, scale regions)