# Task 009: SDF-Based Collision Framework

**Epic:** CLOTH-001  
**Milestone:** 3 - Collision System  
**Effort:** 3 days (8 story points)  
**Priority:** Critical Path  
**Parallelizable:** No - Foundation for all collision features  

## Overview

Implement a robust Signed Distance Field (SDF) based collision detection framework supporting sphere and plane collision primitives with multiple collider support and spatial organization. This system will provide the foundation for all collision interactions in the cloth simulation.

## Technical Requirements

### SDF Collision Architecture
- Signed distance field based collision detection pipeline
- Support for sphere and plane collision primitives  
- Multiple simultaneous colliders with spatial organization
- Efficient GPU-based distance queries and collision detection

### Collision Primitive Support
```rust
#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct SphereCollider {
    center: Vec3,
    radius: f32,
    material_id: u32,
    is_active: u32,
    _padding: [u32; 2],
}

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct PlaneCollider {
    normal: Vec3,
    distance: f32,
    material_id: u32,
    is_active: u32,
    _padding: [u32; 2],
}
```

### GPU Collision Detection Pipeline
```wgsl
@compute @workgroup_size(64, 1, 1)
fn detect_collisions(
    @builtin(global_invocation_id) id: vec3<u32>
) {
    let particle_id = id.x;
    if (particle_id >= particle_count) { return; }
    
    let position = positions[particle_id].xyz;
    var min_distance = 1e10;
    var collision_normal = vec3<f32>(0.0, 1.0, 0.0);
    var has_collision = false;
    
    // Test against all sphere colliders
    for (var i = 0u; i < sphere_count; i++) {
        let sphere = sphere_colliders[i];
        if (sphere.is_active == 0u) { continue; }
        
        let distance = sdf_sphere(position, sphere.center, sphere.radius);
        if (distance < min_distance) {
            min_distance = distance;
            collision_normal = normalize(position - sphere.center);
            has_collision = distance < 0.0;
        }
    }
    
    // Test against all plane colliders
    for (var i = 0u; i < plane_count; i++) {
        let plane = plane_colliders[i];
        if (plane.is_active == 0u) { continue; }
        
        let distance = sdf_plane(position, plane.normal, plane.distance);
        if (distance < min_distance) {
            min_distance = distance;
            collision_normal = plane.normal;
            has_collision = distance < 0.0;
        }
    }
    
    // Store collision results
    collision_data[particle_id] = CollisionResult(
        min_distance,
        collision_normal,
        select(0u, 1u, has_collision)
    );
}
```

## Implementation Details

### SDF Function Library
```wgsl
// Sphere SDF
fn sdf_sphere(point: vec3<f32>, center: vec3<f32>, radius: f32) -> f32 {
    return distance(point, center) - radius;
}

// Plane SDF  
fn sdf_plane(point: vec3<f32>, normal: vec3<f32>, distance: f32) -> f32 {
    return dot(point, normal) - distance;
}

// Box SDF (for future extension)
fn sdf_box(point: vec3<f32>, center: vec3<f32>, size: vec3<f32>) -> f32 {
    let d = abs(point - center) - size * 0.5;
    return length(max(d, vec3<f32>(0.0))) + min(max(d.x, max(d.y, d.z)), 0.0);
}
```

### Collision Data Management
```rust
struct CollisionSystem {
    sphere_colliders: Vec<SphereCollider>,
    plane_colliders: Vec<PlaneCollider>,
    collision_buffer: wgpu::Buffer,
    collision_results: wgpu::Buffer,
    max_colliders: u32,
}

impl CollisionSystem {
    pub fn add_sphere(&mut self, center: Vec3, radius: f32) -> ColliderHandle {
        let collider = SphereCollider {
            center,
            radius,
            material_id: 0,
            is_active: 1,
            _padding: [0; 2],
        };
        self.sphere_colliders.push(collider);
        ColliderHandle::Sphere(self.sphere_colliders.len() - 1)
    }
    
    pub fn add_plane(&mut self, normal: Vec3, distance: f32) -> ColliderHandle {
        let collider = PlaneCollider {
            normal,
            distance,
            material_id: 0,
            is_active: 1,
            _padding: [0; 2],
        };
        self.plane_colliders.push(collider);
        ColliderHandle::Plane(self.plane_colliders.len() - 1)
    }
    
    pub fn update_buffers(&mut self, queue: &wgpu::Queue) {
        // Upload collider data to GPU
        queue.write_buffer(&self.collision_buffer, 0, bytemuck::cast_slice(&self.sphere_colliders));
        // ... plane colliders
    }
}
```

### Spatial Organization
```rust
struct CollisionSpatialGrid {
    grid_size: Vec3,
    cell_size: f32,
    grid_cells: Vec<Vec<ColliderHandle>>,
}

impl CollisionSpatialGrid {
    fn get_potential_colliders(&self, position: Vec3) -> &[ColliderHandle] {
        let cell_index = self.position_to_cell(position);
        &self.grid_cells[cell_index]
    }
    
    fn update_collider_placement(&mut self, handle: ColliderHandle, bounds: AABB) {
        // Update spatial grid with collider bounds
    }
}
```

### Collision Result Storage
```rust
#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct CollisionResult {
    distance: f32,           // Signed distance to closest surface
    normal: Vec3,            // Surface normal at collision point
    has_collision: u32,      // Boolean flag for collision occurrence
    material_id: u32,        // Material properties for response
}
```

## Acceptance Criteria

- [ ] **Sphere Collision**: Accurate collision detection with spherical obstacles
- [ ] **Plane Collision**: Correct collision detection with infinite planes
- [ ] **Multiple Colliders**: Support for simultaneous collision with multiple objects
- [ ] **Performance**: Collision detection completes in <3ms per frame on GTX 1660
- [ ] **Accuracy**: No false positives or negatives in collision detection
- [ ] **Scalability**: Support for up to 32 colliders without significant performance loss

## Dependencies

### Prerequisites
- Task 001 (GPU Buffer Management System) - collision data buffers
- Task 002 (Basic XPBD Physics Pipeline) - integration point for collision constraints
- Mathematical foundation for SDF functions

### Blocks
- Task 010 (Collision Response System) - requires collision detection data
- Task 011 (Debug Visualization) - visualizes collision detection results

### Can Work In Parallel With
- Task 006 (Advanced Force System) - independent physics feature
- Task 007 (GPU-based Normal Computation) - different subsystem

## Testing Strategy

### SDF Function Tests
```rust
#[test]
fn sdf_sphere_accuracy() {
    // Test sphere SDF against analytical solutions
    assert!((sdf_sphere(Vec3::ZERO, Vec3::ZERO, 1.0) - (-1.0)).abs() < 1e-6);
    assert!((sdf_sphere(Vec3::new(2.0, 0.0, 0.0), Vec3::ZERO, 1.0) - 1.0).abs() < 1e-6);
}

#[test]
fn sdf_plane_accuracy() {
    // Test plane SDF against analytical solutions
    let normal = Vec3::new(0.0, 1.0, 0.0);
    assert!((sdf_plane(Vec3::new(0.0, 1.0, 0.0), normal, 0.0) - 1.0).abs() < 1e-6);
}

#[test]
fn collision_detection_performance() {
    // Benchmark collision detection with multiple colliders
}
```

### Integration Tests
- Multi-collider collision scenarios
- Edge case testing (tangent surfaces, multiple simultaneous collisions)
- Performance scaling with collider count
- Memory usage validation

## Technical Specifications

### Buffer Layout
```rust
struct CollisionBuffers {
    sphere_colliders: Buffer<SphereCollider>,    // Sphere collision primitives
    plane_colliders: Buffer<PlaneCollider>,      // Plane collision primitives
    collision_results: Buffer<CollisionResult>,  // Per-particle collision results
    collider_counts: Buffer<u32>,                // [sphere_count, plane_count]
}
```

### Shader Interface
```wgsl
@group(1) @binding(0) var<storage, read> sphere_colliders: array<SphereCollider>;
@group(1) @binding(1) var<storage, read> plane_colliders: array<PlaneCollider>;
@group(1) @binding(2) var<storage, read_write> collision_data: array<CollisionResult>;
@group(1) @binding(3) var<uniform> collider_info: ColliderInfo;

struct ColliderInfo {
    sphere_count: u32,
    plane_count: u32,
    collision_threshold: f32,
    _padding: u32,
}
```

## Performance Targets

- **Collision Detection**: <3ms per frame for 1024 particles and 16 colliders
- **Memory Usage**: <1MB for collision data structures
- **Scalability**: Linear performance scaling with collider count
- **GPU Utilization**: >80% compute occupancy during collision detection

## Risk Factors

- **Performance Scaling**: Many colliders may cause performance bottlenecks
- **Memory Bandwidth**: Multiple SDF evaluations may be memory bound
- **Precision Issues**: Floating-point precision near surfaces
- **Spatial Coherence**: Poor spatial organization may cause cache misses

## Implementation Notes

### SDF Algorithm Selection
- Choose simple, fast SDF functions over complex but accurate ones
- Consider approximations for complex shapes to maintain performance
- Implement distance field gradients for smooth normal computation

### Spatial Optimization
- Consider implementing broad-phase collision culling
- Use spatial grids or other acceleration structures for many colliders
- Profile memory access patterns for optimization opportunities

### Future Extensions
- Design system to easily add new primitive types (capsules, boxes)
- Consider support for animated/moving colliders
- Plan for mesh-based collision using distance field textures

### Debug and Validation
- Implement collision visualization for debugging
- Add collision count statistics for performance monitoring
- Consider collision history tracking for temporal coherence