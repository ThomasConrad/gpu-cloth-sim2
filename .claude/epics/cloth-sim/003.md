# Task 003: Minimal Rendering Pipeline

**Epic:** CLOTH-001  
**Milestone:** 1 - Foundation  
**Effort:** 2 days (5 story points)  
**Priority:** Critical Path  
**Parallelizable:** Yes - Can work parallel to physics once buffers exist  

## Overview

Implement a minimal but efficient rendering pipeline using vertex pulling from GPU compute buffers. This eliminates CPU-GPU data transfer by rendering directly from physics simulation buffers with basic triangle mesh rendering and simple Lambertian lighting.

## Technical Requirements

### Vertex Pulling Architecture
- Direct rendering from compute buffers without CPU transfer
- Vertex shader pulls data using vertex index
- No vertex buffer objects - use storage buffers instead
- Dynamic mesh topology support for different cloth resolutions

### Rendering Pipeline Components
```wgsl
// Vertex Shader with Vertex Pulling
@vertex
fn vertex_main(
    @builtin(vertex_index) vertex_index: u32,
    @builtin(instance_index) instance_index: u32
) -> VertexOutput {
    // Pull position from physics buffer
    // Calculate world-space position
    // Apply view/projection transforms
}

// Fragment Shader with Simple Lighting
@fragment  
fn fragment_main(
    input: VertexOutput
) -> @location(0) vec4<f32> {
    // Lambertian diffuse lighting
    // Simple material properties
}
```

### Mesh Generation
```rust
struct ClothMesh {
    width: u32,           // Cloth grid width
    height: u32,          // Cloth grid height
    indices: Vec<u32>,    // Triangle indices for rendering
    topology: Topology,   // Triangle list topology
}

impl ClothMesh {
    fn generate_indices(width: u32, height: u32) -> Vec<u32>;
    fn get_index_count(&self) -> u32;
}
```

## Implementation Details

### Buffer Binding Strategy
- Bind physics position buffer as storage buffer in vertex shader
- Use @group(0) @binding(0) for position data access
- Uniform buffer for view/projection matrices
- Push constants for per-frame parameters

### Index Buffer Generation
```rust
// Generate triangle indices for quad grid
fn generate_cloth_indices(width: u32, height: u32) -> Vec<u32> {
    let mut indices = Vec::new();
    for y in 0..(height - 1) {
        for x in 0..(width - 1) {
            let base = y * width + x;
            // First triangle
            indices.extend_from_slice(&[base, base + 1, base + width]);
            // Second triangle  
            indices.extend_from_slice(&[base + 1, base + width + 1, base + width]);
        }
    }
    indices
}
```

### Camera System
- Simple orbital camera for cloth viewing
- View matrix generation with look-at
- Perspective projection with configurable FOV
- Mouse controls for camera rotation (basic)

### Lighting Model
- Single directional light source
- Lambertian diffuse shading: I = I₀ * max(0, N·L)
- Fixed normal calculation (will be improved in later tasks)
- Simple material properties (albedo, ambient)

## Acceptance Criteria

- [ ] **Vertex Pulling**: Successfully render cloth using storage buffer positions
- [ ] **Mesh Quality**: Triangle mesh renders without gaps or incorrect topology
- [ ] **Performance**: Rendering completes in <2ms per frame on GTX 1660
- [ ] **Visual Quality**: Clear cloth structure visible with proper triangle connectivity
- [ ] **Camera Control**: Basic camera rotation allows viewing from different angles
- [ ] **Lighting**: Diffuse shading provides adequate depth perception

## Dependencies

### Prerequisites
- Task 001 (GPU Buffer Management System) - requires position buffers
- Task 002 (Basic XPBD Physics Pipeline) - needs physics data to render
- wgpu render pipeline initialization
- Basic shader compilation system

### Blocks
- Task 009 (GPU-based Normal Computation) - improves this rendering
- Task 010 (Wireframe Overlay) - extends rendering capabilities

### Can Work In Parallel With
- Task 004 (Application Framework) - different subsystem
- Task 005 (Shader Architecture Setup) - complementary work

## Testing Strategy

### Visual Validation
```rust
#[test]
fn mesh_topology_correctness() {
    // Verify index buffer generates correct triangle connectivity
}

#[test]
fn vertex_pulling_accuracy() {
    // Test vertex shader correctly accesses position data
}

#[test]
fn rendering_performance() {
    // Benchmark rendering pipeline performance
}
```

### Rendering Tests
- Screenshot comparison for visual regression testing
- Performance benchmarking across different mesh resolutions
- Memory usage validation during rendering

## Technical Specifications

### Shader Interface
```wgsl
struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) world_pos: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
}

struct Uniforms {
    view_matrix: mat4x4<f32>,
    proj_matrix: mat4x4<f32>,
    light_direction: vec3<f32>,
    light_color: vec3<f32>,
}
```

### Render State
- Cull mode: Back face culling enabled
- Depth test: Less-equal comparison
- Blend state: Disabled (opaque rendering)
- Primitive topology: Triangle list

## Performance Targets

- **Render Time**: <2ms per frame for 32x32 cloth grid
- **GPU Memory**: Minimal additional memory overhead
- **Vertex Throughput**: Handle 50K vertices at 60 FPS
- **Shader Performance**: Vertex shader <100 instructions

## Risk Factors

- **Storage Buffer Limits**: Some hardware may have limited storage buffer support
- **Vertex Pulling Performance**: May be slower than traditional vertex buffers
- **Index Buffer Size**: Large cloth meshes may exceed index buffer limits
- **Precision Issues**: Float precision in vertex shader calculations

## Implementation Notes

- Start with wireframe rendering for debugging
- Implement depth buffer for proper occlusion
- Consider backface culling for performance
- Plan for normal computation upgrade in later tasks
- Keep shaders simple - optimization comes in Milestone 5