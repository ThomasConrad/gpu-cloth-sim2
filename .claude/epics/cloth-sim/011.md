# Task 011: Debug Visualization System

**Epic:** CLOTH-001  
**Milestone:** 3 - Collision System  
**Effort:** 2 days (5 story points)  
**Priority:** Medium  
**Parallelizable:** Yes - Independent rendering feature  

## Overview

Implement comprehensive debug visualization system including collision shape rendering overlay, constraint force visualization, penetration depth indicators, and performance profiling displays. This system will be crucial for debugging physics behavior and performance optimization.

## Technical Requirements

### Collision Shape Visualization
- Render collision primitives (spheres, planes) as wireframe overlays
- Color-coding for different collision materials and states
- Toggle visibility for individual collider types
- Real-time updates as colliders move or change

### Constraint Force Visualization
- Vector field rendering for constraint forces
- Color-coding by force magnitude and type
- Scaling controls for force vector visibility
- Per-particle force accumulation display

### Debug Rendering Pipeline
```rust
struct DebugRenderer {
    line_vertex_buffer: wgpu::Buffer,
    sphere_wireframe_buffer: wgpu::Buffer,
    debug_line_pipeline: wgpu::RenderPipeline,
    debug_point_pipeline: wgpu::RenderPipeline,
    force_vector_pipeline: wgpu::RenderPipeline,
}

impl DebugRenderer {
    pub fn render_collision_shapes(&mut self, colliders: &CollisionSystem, encoder: &mut wgpu::CommandEncoder) {
        // Render sphere wireframes
        for sphere in &colliders.sphere_colliders {
            self.draw_sphere_wireframe(sphere.center, sphere.radius, Color::RED);
        }
        
        // Render plane boundaries
        for plane in &colliders.plane_colliders {
            self.draw_plane_outline(plane.normal, plane.distance, Color::BLUE);
        }
    }
    
    pub fn render_force_vectors(&mut self, forces: &[Vec4], positions: &[Vec4], scale: f32) {
        for (i, (&force, &pos)) in forces.iter().zip(positions.iter()).enumerate() {
            if force.xyz().length() > 0.01 {
                let color = self.force_magnitude_to_color(force.xyz().length());
                self.draw_vector(pos.xyz(), pos.xyz() + force.xyz() * scale, color);
            }
        }
    }
}
```

### Performance Profiling Overlay
```rust
struct PerformanceOverlay {
    frame_times: RingBuffer<f32, 60>,
    gpu_timings: HashMap<String, f32>,
    physics_stats: PhysicsStatistics,
    memory_usage: MemoryStatistics,
}

struct PhysicsStatistics {
    constraint_iterations: u32,
    collision_count: u32,
    unstable_particles: u32,
    average_constraint_error: f32,
    solver_convergence_rate: f32,
}
```

## Implementation Details

### Debug Line Rendering
```wgsl
// Debug Line Vertex Shader
struct LineVertex {
    @location(0) position: vec3<f32>,
    @location(1) color: vec3<f32>,
}

struct LineUniforms {
    view_proj: mat4x4<f32>,
    line_width: f32,
}

@vertex
fn line_vertex_main(vertex: LineVertex) -> VertexOutput {
    let world_pos = vec4(vertex.position, 1.0);
    let clip_pos = uniforms.view_proj * world_pos;
    
    return VertexOutput(
        clip_pos,
        vertex.color,
    );
}

@fragment
fn line_fragment_main(input: VertexOutput) -> @location(0) vec4<f32> {
    return vec4(input.color, 1.0);
}
```

### Wireframe Generation
```rust
fn generate_sphere_wireframe(center: Vec3, radius: f32, segments: u32) -> Vec<LineVertex> {
    let mut vertices = Vec::new();
    
    // Generate latitude lines
    for lat in 0..segments {
        let theta = (lat as f32) * std::f32::consts::PI / (segments as f32);
        let y = radius * theta.cos();
        let ring_radius = radius * theta.sin();
        
        for lon in 0..segments {
            let phi = (lon as f32) * 2.0 * std::f32::consts::PI / (segments as f32);
            let x = ring_radius * phi.cos();
            let z = ring_radius * phi.sin();
            
            vertices.push(LineVertex {
                position: center + Vec3::new(x, y, z),
                color: Vec3::new(1.0, 0.0, 0.0), // Red for spheres
            });
        }
    }
    
    vertices
}
```

### Constraint Force Visualization
```rust
impl DebugRenderer {
    fn visualize_stretch_forces(&mut self, constraints: &[StretchConstraint], positions: &[Vec4]) {
        for constraint in constraints {
            let pos_a = positions[constraint.particle_a as usize].xyz();
            let pos_b = positions[constraint.particle_b as usize].xyz();
            
            let current_length = (pos_b - pos_a).length();
            let strain = (current_length - constraint.rest_length) / constraint.rest_length;
            
            // Color code by strain: blue (compression) to red (tension)
            let color = if strain > 0.0 {
                Vec3::lerp(Vec3::new(1.0, 1.0, 0.0), Vec3::new(1.0, 0.0, 0.0), strain.min(1.0))
            } else {
                Vec3::lerp(Vec3::new(1.0, 1.0, 0.0), Vec3::new(0.0, 0.0, 1.0), (-strain).min(1.0))
            };
            
            self.draw_line(pos_a, pos_b, color);
        }
    }
    
    fn visualize_collision_penetration(&mut self, collision_results: &[CollisionResult], positions: &[Vec4]) {
        for (i, result) in collision_results.iter().enumerate() {
            if result.has_collision && result.distance < 0.0 {
                let pos = positions[i].xyz();
                let penetration_depth = -result.distance;
                
                // Draw penetration vector
                let end_pos = pos + result.normal * penetration_depth;
                let color = Vec3::lerp(
                    Vec3::new(1.0, 0.5, 0.0), // Orange
                    Vec3::new(1.0, 0.0, 0.0), // Red
                    (penetration_depth * 10.0).min(1.0)
                );
                
                self.draw_vector(pos, end_pos, color);
            }
        }
    }
}
```

### UI Debug Controls
```rust
struct DebugUI {
    show_collision_shapes: bool,
    show_constraint_forces: bool,
    show_penetration_vectors: bool,
    show_performance_overlay: bool,
    force_vector_scale: f32,
    wireframe_opacity: f32,
}

impl DebugUI {
    fn render_debug_panel(&mut self, ui: &mut egui::Ui) {
        ui.collapsing("Collision Debug", |ui| {
            ui.checkbox(&mut self.show_collision_shapes, "Show Collision Shapes");
            ui.checkbox(&mut self.show_penetration_vectors, "Show Penetration Vectors");
        });
        
        ui.collapsing("Physics Debug", |ui| {
            ui.checkbox(&mut self.show_constraint_forces, "Show Constraint Forces");
            ui.slider(&mut self.force_vector_scale, 0.1..=10.0, "Force Vector Scale");
        });
        
        ui.collapsing("Performance", |ui| {
            ui.checkbox(&mut self.show_performance_overlay, "Show Performance Overlay");
            // Performance statistics display
        });
    }
}
```

## Acceptance Criteria

- [ ] **Collision Visualization**: Collision shapes render correctly with proper wireframes
- [ ] **Force Vectors**: Constraint forces displayed as scaled, color-coded vectors
- [ ] **Penetration Indicators**: Clear visualization of collision penetration depth and direction
- [ ] **Performance Display**: Real-time performance metrics clearly visible
- [ ] **Interactive Controls**: Debug visualization can be toggled and configured via UI
- [ ] **Minimal Performance Impact**: Debug rendering adds <1ms per frame when enabled

## Dependencies

### Prerequisites
- Task 009 (SDF-Based Collision Framework) - collision shape data
- Task 010 (Collision Response System) - collision force data
- Task 003 (Minimal Rendering Pipeline) - rendering infrastructure
- Task 004 (Application Framework) - UI integration

### Enhances
- All physics tasks - provides debugging capability
- Performance optimization tasks - provides profiling data

### Can Work In Parallel With
- Task 012 (Interactive Vertex Manipulation) - different feature area
- Task 013 (Advanced Parameter Controls) - different UI feature

## Testing Strategy

### Visual Validation
```rust
#[test]
fn debug_rendering_accuracy() {
    // Test that debug visualizations match physics simulation state
}

#[test]
fn performance_overlay_accuracy() {
    // Verify performance statistics are calculated correctly
}

#[test]
fn debug_ui_responsiveness() {
    // Test that debug controls update visualization in real-time
}
```

### Performance Testing
- Measure debug rendering overhead
- Test debug system performance with various particle counts
- Validate memory usage of debug buffers

## Technical Specifications

### Debug Buffer Layout
```rust
struct DebugBuffers {
    debug_lines: Buffer<LineVertex>,
    debug_points: Buffer<PointVertex>,
    force_vectors: Buffer<VectorVertex>,
    collision_indicators: Buffer<CollisionIndicator>,
}

struct VectorVertex {
    start: Vec3,
    end: Vec3,
    color: Vec3,
    thickness: f32,
}
```

### Rendering Pipeline Configuration
```rust
struct DebugRenderPipelines {
    line_pipeline: wgpu::RenderPipeline,
    point_pipeline: wgpu::RenderPipeline,
    vector_pipeline: wgpu::RenderPipeline,
    wireframe_pipeline: wgpu::RenderPipeline,
}
```

### Performance Monitoring
```rust
struct GPUTimer {
    timestamp_queries: Vec<wgpu::QuerySet>,
    timestamp_buffer: wgpu::Buffer,
    current_query_index: usize,
}

impl GPUTimer {
    fn begin_timing(&mut self, label: &str) {
        // Start GPU timestamp query
    }
    
    fn end_timing(&mut self, label: &str) -> f32 {
        // End GPU timestamp query and return elapsed time
    }
}
```

## Performance Targets

- **Debug Rendering**: <1ms per frame when all debug features enabled
- **Memory Usage**: <10MB additional memory for debug buffers
- **UI Responsiveness**: Debug control changes take effect within 1 frame
- **Profiling Accuracy**: Performance measurements accurate to within 5%

## Risk Factors

- **Performance Impact**: Complex debug rendering may significantly impact performance
- **Memory Usage**: Debug buffers may consume significant GPU memory
- **Visual Clutter**: Too many debug visualizations may obscure the simulation
- **Platform Differences**: Debug rendering behavior may vary across graphics APIs

## Implementation Notes

### Color Coding Strategy
- **Collision Shapes**: Red for spheres, Blue for planes, Green for active collisions
- **Forces**: Blue (compression) → Yellow (neutral) → Red (tension)
- **Penetration**: Orange → Red based on depth
- **Performance**: Green (good) → Yellow (caution) → Red (poor)

### Optimization Considerations
- Use instanced rendering for repeated debug shapes
- Implement frustum culling for debug geometry
- Consider level-of-detail for complex debug visualizations
- Cache debug geometry when simulation state doesn't change

### User Experience
- Provide preset debug configurations for common use cases
- Implement debug overlay fade-in/out animations
- Consider context-sensitive debug information display
- Ensure debug UI doesn't interfere with simulation controls

### Future Extensions
- Save/load debug visualization configurations
- Screenshot capture with debug overlays
- Debug information export for external analysis
- Integration with external profiling tools