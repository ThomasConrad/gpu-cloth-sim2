# Task 002: Basic XPBD Physics Pipeline

**Epic:** CLOTH-001  
**Milestone:** 1 - Foundation  
**Effort:** 3 days (8 story points)  
**Priority:** Critical Path  
**Parallelizable:** No - Core physics foundation  

## Overview

Implement the core Extended Position-Based Dynamics (XPBD) physics pipeline using compute shaders. This includes position integration, stretch constraint solving with parallel Jacobi iteration, gravity application, and ground plane collision.

## Technical Requirements

### XPBD Algorithm Implementation
- Position integration using Verlet-style integration
- Stretch constraint solving with compliance-based approach
- Parallel Jacobi iteration to avoid atomic operations
- Ground plane collision constraint integration

### Compute Shader Architecture
```wgsl
// Position Integration Shader
@compute @workgroup_size(64, 1, 1)
fn integrate_positions(
    @builtin(global_invocation_id) id: vec3<u32>
) {
    // Verlet integration with external forces
    // Position prediction step
}

// Constraint Solving Shader  
@compute @workgroup_size(64, 1, 1)
fn solve_constraints(
    @builtin(global_invocation_id) id: vec3<u32>
) {
    // Parallel Jacobi constraint satisfaction
    // Stretch constraint implementation
}
```

### Physics Parameters
```rust
struct PhysicsParams {
    time_step: f32,           // Simulation timestep (1/60 typical)
    damping: f32,             // Velocity damping coefficient
    compliance: f32,          // Material compliance (inverse stiffness)
    gravity: Vec3,            // Gravity acceleration vector
    ground_height: f32,       // Ground plane Y coordinate
}
```

## Implementation Details

### Integration Pipeline
1. **Force Accumulation**: Gather external forces (gravity, user forces)
2. **Position Prediction**: Apply Verlet integration step
3. **Constraint Solving**: Iterative constraint satisfaction (5-10 iterations)
4. **Velocity Update**: Derive velocities from position changes
5. **Collision Response**: Ground plane collision handling

### Constraint Representation
```rust
struct StretchConstraint {
    particle_a: u32,         // First particle index
    particle_b: u32,         // Second particle index  
    rest_length: f32,        // Target constraint length
    compliance: f32,         // Material compliance parameter
}
```

### Solver Implementation
- Use lambda-based position corrections
- Implement compliance for different material stiffness
- Parallel processing of non-conflicting constraints
- Convergence monitoring and iteration limiting

## Acceptance Criteria

- [ ] **Integration Stability**: Position integration remains stable for 1000+ timesteps
- [ ] **Constraint Satisfaction**: Stretch constraints maintain rest lengths within 5% error
- [ ] **Performance**: Physics pipeline completes in <8ms per frame on GTX 1660
- [ ] **Ground Collision**: Cloth particles correctly collide with ground plane
- [ ] **Parameter Response**: Changes to stiffness/damping produce expected behavioral changes
- [ ] **Numerical Stability**: No particle positions become NaN or infinite

## Dependencies

### Prerequisites
- Task 001 (GPU Buffer Management System) - requires physics buffers
- Compute shader compilation pipeline
- Mathematics library (glam) integration

### Blocks
- Task 003 (Minimal Rendering Pipeline) - needs stable particle positions
- Task 007 (Bending Constraints) - extends this constraint system
- Task 008 (Advanced Force System) - builds on force accumulation

### Can Work In Parallel With
- Task 004 (Application Framework) - different subsystem

## Testing Strategy

### Unit Tests
```rust
#[test]
fn verlet_integration_accuracy() {
    // Test position integration mathematical accuracy
}

#[test]
fn constraint_convergence() {
    // Verify constraint solver converges to rest length
}

#[test] 
fn parameter_stability() {
    // Test parameter ranges for numerical stability
}
```

### Validation Tests
- Compare against CPU reference implementation
- Energy conservation verification over time
- Constraint error accumulation monitoring
- Performance regression testing

## Mathematical Foundation

### XPBD Formulation
- Position-based approach with compliance regularization
- Lambda calculation: λ = -C(x) / (∇C · M⁻¹∇C + α/dt²)
- Position correction: Δx = M⁻¹∇C λ

### Constraint Functions
- **Stretch**: C(x₁, x₂) = |x₁ - x₂| - rest_length
- **Ground Collision**: C(x) = min(0, x.y - ground_height)

## Performance Targets

- **Physics Step**: <8ms total per frame (32x32 cloth grid)
- **Constraint Iterations**: 5-8 iterations for convergence
- **Memory Bandwidth**: Efficient GPU memory access patterns
- **Workgroup Utilization**: >90% GPU compute occupancy

## Risk Factors

- **Numerical Instability**: Large timesteps may cause solver divergence
- **Constraint Conflicts**: Parallel processing may create race conditions
- **Parameter Sensitivity**: Stiffness values affecting stability
- **Convergence Issues**: Jacobi method may converge slowly for certain configurations

## Implementation Notes

- Start with simple 2-particle stretch test case
- Gradually increase to full cloth grid
- Implement debug readback for constraint error monitoring
- Consider constraint reordering for better convergence