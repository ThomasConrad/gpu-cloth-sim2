# Task 006: Advanced Force System

**Epic:** CLOTH-001  
**Milestone:** 2 - Enhanced Physics  
**Effort:** 2 days (5 story points)  
**Priority:** Medium  
**Parallelizable:** Yes - Independent of bending constraints  

## Overview

Implement an advanced force application system including realistic wind forces with turbulence, user-defined force application via mouse interaction, and a robust force accumulation and integration pipeline that works seamlessly with the XPBD solver.

## Technical Requirements

### Wind Force Implementation
- Realistic wind simulation with directional control
- Turbulence generation for natural cloth movement
- Per-particle wind force calculation based on triangle normal
- Wind strength and direction parameter control

### User Force Interaction
- Mouse-based force application to cloth vertices
- Ray casting from mouse position to world space
- Interactive force direction and magnitude control
- Real-time force visualization feedback

### Force Accumulation Pipeline
```rust
struct ForceSystem {
    gravity_force: Vec3,        // Global gravity acceleration
    wind_direction: Vec3,       // Wind direction vector
    wind_strength: f32,         // Wind force magnitude
    turbulence_scale: f32,      // Turbulence noise scale
    user_force_position: Vec3,  // Mouse interaction point
    user_force_strength: f32,   // User applied force magnitude
}
```

## Implementation Details

### Wind Force Computation
```wgsl
@compute @workgroup_size(64, 1, 1)
fn apply_wind_forces(
    @builtin(global_invocation_id) id: vec3<u32>
) {
    let particle_id = id.x;
    if (particle_id >= particle_count) { return; }
    
    let position = positions[particle_id].xyz;
    
    // Calculate triangle normal for aerodynamic forces
    let normal = calculate_vertex_normal(particle_id);
    
    // Base wind force
    let wind_force = wind_direction * wind_strength;
    
    // Add turbulence using noise function
    let turbulence = generate_turbulence(position, time);
    let total_wind = wind_force + turbulence * turbulence_scale;
    
    // Apply force proportional to surface area and normal alignment
    let force_magnitude = dot(total_wind, normal);
    forces[particle_id] += vec4(total_wind * force_magnitude, 0.0);
}
```

### Turbulence Generation
```rust
fn generate_turbulence(position: Vec3, time: f32) -> Vec3 {
    // Use 3D Perlin/Simplex noise for natural turbulence
    let noise_x = noise_3d(position * 0.1 + Vec3::new(time, 0.0, 0.0));
    let noise_y = noise_3d(position * 0.1 + Vec3::new(0.0, time, 0.0));
    let noise_z = noise_3d(position * 0.1 + Vec3::new(0.0, 0.0, time));
    
    Vec3::new(noise_x, noise_y, noise_z) * 2.0 - Vec3::ONE
}
```

### User Force Application
```rust
struct UserForceInteraction {
    mouse_ray_origin: Vec3,
    mouse_ray_direction: Vec3,
    force_radius: f32,
    force_strength: f32,
    is_active: bool,
}

impl UserForceInteraction {
    fn update(&mut self, mouse_pos: Vec2, camera: &Camera, is_pressed: bool) {
        self.is_active = is_pressed;
        if is_pressed {
            // Convert mouse position to world ray
            let ray = camera.screen_to_world_ray(mouse_pos);
            self.mouse_ray_origin = ray.origin;
            self.mouse_ray_direction = ray.direction;
        }
    }
}
```

### Force Integration Pipeline
1. **Clear Forces**: Reset accumulated forces buffer
2. **Apply Gravity**: Add gravity to all particles
3. **Apply Wind**: Calculate and add wind forces with turbulence
4. **Apply User Forces**: Add mouse interaction forces
5. **Force Integration**: Use in XPBD position prediction step

## Acceptance Criteria

- [ ] **Wind Realism**: Wind forces create natural, believable cloth movement
- [ ] **Turbulence Quality**: Turbulence adds realistic variation without chaos
- [ ] **User Interaction**: Mouse forces feel responsive and intuitive
- [ ] **Performance**: Force calculations complete in <2ms per frame
- [ ] **Parameter Control**: Real-time parameter adjustment works smoothly
- [ ] **Force Visualization**: Debug visualization shows force vectors clearly

## Dependencies

### Prerequisites
- Task 002 (Basic XPBD Physics Pipeline) - force integration point
- Task 001 (GPU Buffer Management System) - force accumulation buffer
- Task 004 (Application Framework) - mouse input handling

### Blocks
- Advanced user interaction features in Milestone 4
- Parameter tuning and preset systems

### Can Work In Parallel With
- Task 005 (Bending Constraints) - different physics subsystem
- Task 007 (GPU-based Normal Computation) - rendering system

## Testing Strategy

### Force Validation Tests
```rust
#[test]
fn wind_force_direction() {
    // Test wind forces align with specified direction
}

#[test]
fn force_accumulation() {
    // Verify multiple forces accumulate correctly
}

#[test]
fn user_force_interaction() {
    // Test mouse ray casting and force application
}
```

### Physics Validation
- Wind force magnitude verification
- Energy input analysis (forces should add energy to system)
- Stability testing with various force magnitudes
- Interactive force responsiveness measurement

## Technical Specifications

### Force Buffer Layout
```rust
struct ForceBuffer {
    gravity_forces: Buffer<Vec4>,     // Per-particle gravity
    wind_forces: Buffer<Vec4>,        // Per-particle wind forces
    user_forces: Buffer<Vec4>,        // User interaction forces
    accumulated_forces: Buffer<Vec4>, // Final force sum
}
```

### Noise Implementation
- 3D Simplex noise for turbulence generation
- Time-varying noise parameters for animation
- Configurable noise scale and amplitude
- GPU-friendly noise function implementation

### Mouse Ray Casting
```rust
struct Ray {
    origin: Vec3,
    direction: Vec3,
}

impl Camera {
    fn screen_to_world_ray(&self, screen_pos: Vec2) -> Ray {
        // Convert screen coordinates to normalized device coordinates
        // Unproject to world space using inverse view-projection matrix
        // Return ray from camera through world point
    }
}
```

## Performance Targets

- **Wind Force Computation**: <1ms per frame for 1024 particles
- **Turbulence Generation**: Efficient GPU noise evaluation
- **User Force Response**: <16ms latency from mouse to visual feedback
- **Memory Usage**: Minimal additional GPU memory for force buffers

## Risk Factors

- **Noise Quality vs Performance**: Complex noise may be too expensive
- **Force Magnitude Tuning**: Forces may overpower or underwhelm physics
- **Numerical Stability**: Large forces may destabilize solver
- **User Experience**: Force interaction may feel unnatural or delayed

## Implementation Notes

### Wind Force Algorithm
- Consider using triangle area weighting for more accurate aerodynamics
- Implement wind shadow effects for occluded areas
- Allow for directional variation across the cloth surface

### Turbulence Considerations
- Use time-based noise seeding for consistent but dynamic turbulence
- Consider multiple octaves of noise for more complex patterns
- Profile different noise algorithms (Perlin vs Simplex vs custom)

### User Interaction Design
- Provide visual feedback for force application point
- Consider force falloff with distance from mouse
- Implement force direction control (push/pull modes)
- Add force magnitude visualization